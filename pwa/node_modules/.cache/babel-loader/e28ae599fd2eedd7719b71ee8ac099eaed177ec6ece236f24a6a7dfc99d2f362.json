{"ast":null,"code":"// ============================================================================\n// MOCK BACKEND - UNIFIED BUBBLE PHILOSOPHY\n// ============================================================================\n\nlet mockDB = {\n  users: [{\n    id: 'user1',\n    email: 'owner@example.com',\n    type: 'owner'\n  }, {\n    id: 'user2',\n    email: 'participant1@example.com',\n    type: 'participant'\n  }, {\n    id: 'user3',\n    email: 'participant2@example.com',\n    type: 'participant'\n  }],\n  // ONE BUBBLE = ONE SHARED SPACE\n  bubbles: [{\n    bubbleId: 'bubble1',\n    name: 'Family Safety Circle',\n    createdBy: 'user1',\n    createdAt: Date.now()\n  }],\n  // All members belong to the SAME bubble\n  members: [{\n    memberId: 'member1',\n    userId: 'user1',\n    bubbleId: 'bubble1',\n    name: 'Sarah',\n    status: 'Safe',\n    role: 'owner',\n    joinedAt: Date.now()\n  }, {\n    memberId: 'member2',\n    userId: 'user2',\n    bubbleId: 'bubble1',\n    name: 'Mom',\n    status: 'Busy',\n    role: 'member',\n    joinedAt: Date.now()\n  }, {\n    memberId: 'member3',\n    userId: 'user3',\n    bubbleId: 'bubble1',\n    name: 'Dad',\n    status: 'Safe',\n    role: 'member',\n    joinedAt: Date.now()\n  }],\n  referrals: []\n};\nexport const API = {\n  // Create a new bubble (only when first user signs up)\n  createBubble: async (userId, firstName, lastName, bubbleName, userPhoto, relationshipRole) => {\n    const bubbleId = `bubble${Date.now()}`;\n    const memberId = `member${Date.now()}`;\n    const fullName = `${firstName} ${lastName}`;\n    mockDB.bubbles.push({\n      bubbleId,\n      name: bubbleName || `${fullName}'s Bubble`,\n      createdBy: userId,\n      createdAt: Date.now()\n    });\n    mockDB.members.push({\n      memberId,\n      userId,\n      bubbleId,\n      name: fullName,\n      firstName,\n      lastName,\n      userPhoto,\n      relationshipRole,\n      status: 'Safe',\n      role: 'owner',\n      joinedAt: Date.now()\n    });\n    return {\n      bubbleId,\n      memberId\n    };\n  },\n  // Generate referral for the BUBBLE (not for individual user)\n  generateReferral: async bubbleId => {\n    const token = `BUB${Math.random().toString(36).substr(2, 9).toUpperCase()}`;\n    mockDB.referrals.push({\n      token,\n      bubbleId,\n      used: false,\n      createdAt: Date.now()\n    });\n    return {\n      token\n    };\n  },\n  // Join existing bubble = you see the SAME bubble as everyone else\n  joinBubble: async (token, userId, userName) => {\n    const ref = mockDB.referrals.find(r => r.token === token && !r.used);\n    if (!ref) throw new Error('Invalid invite code');\n    const memberId = `member${Date.now()}`;\n    mockDB.members.push({\n      memberId,\n      userId,\n      bubbleId: ref.bubbleId,\n      name: userName,\n      status: 'Offline',\n      role: 'member',\n      joinedAt: Date.now()\n    });\n    ref.used = true;\n    return {\n      bubbleId: ref.bubbleId,\n      memberId\n    };\n  },\n  // Get the ONE bubble this user belongs to\n  getUserBubble: async userId => {\n    const member = mockDB.members.find(m => m.userId === userId);\n    if (!member) return null;\n    const bubble = mockDB.bubbles.find(b => b.bubbleId === member.bubbleId);\n    const allMembers = mockDB.members.filter(m => m.bubbleId === member.bubbleId);\n    return {\n      bubble,\n      currentMember: member,\n      allMembers: allMembers.map(m => ({\n        ...m,\n        isMe: m.userId === userId\n      }))\n    };\n  },\n  // Update status in the shared bubble\n  updateStatus: async (memberId, status) => {\n    const member = mockDB.members.find(m => m.memberId === memberId);\n    if (member) {\n      member.status = status;\n      member.lastUpdated = Date.now();\n    }\n    return {\n      success: true\n    };\n  },\n  // Everyone in the bubble can invite (optional: restrict to owner only)\n  canInvite: async memberId => {\n    const member = mockDB.members.find(m => m.memberId === memberId);\n    // Philosophy: Anyone in the bubble can grow it\n    return member ? true : false;\n  },\n  // Leave bubble\n  leaveBubble: async memberId => {\n    const index = mockDB.members.findIndex(m => m.memberId === memberId);\n    if (index > -1) {\n      mockDB.members.splice(index, 1);\n    }\n    return {\n      success: true\n    };\n  }\n};","map":{"version":3,"names":["mockDB","users","id","email","type","bubbles","bubbleId","name","createdBy","createdAt","Date","now","members","memberId","userId","status","role","joinedAt","referrals","API","createBubble","firstName","lastName","bubbleName","userPhoto","relationshipRole","fullName","push","generateReferral","token","Math","random","toString","substr","toUpperCase","used","joinBubble","userName","ref","find","r","Error","getUserBubble","member","m","bubble","b","allMembers","filter","currentMember","map","isMe","updateStatus","lastUpdated","success","canInvite","leaveBubble","index","findIndex","splice"],"sources":["C:/Users/ADMIN/FamilyBubble/pwa/src/services/bubble.js"],"sourcesContent":["// ============================================================================\n// MOCK BACKEND - UNIFIED BUBBLE PHILOSOPHY\n// ============================================================================\n\nlet mockDB = {\n  users: [\n    { id: 'user1', email: 'owner@example.com', type: 'owner' },\n    { id: 'user2', email: 'participant1@example.com', type: 'participant' },\n    { id: 'user3', email: 'participant2@example.com', type: 'participant' }\n  ],\n  // ONE BUBBLE = ONE SHARED SPACE\n  bubbles: [\n    { \n      bubbleId: 'bubble1', \n      name: 'Family Safety Circle',\n      createdBy: 'user1',\n      createdAt: Date.now()\n    }\n  ],\n  // All members belong to the SAME bubble\n  members: [\n    { memberId: 'member1', userId: 'user1', bubbleId: 'bubble1', name: 'Sarah', status: 'Safe', role: 'owner', joinedAt: Date.now() },\n    { memberId: 'member2', userId: 'user2', bubbleId: 'bubble1', name: 'Mom', status: 'Busy', role: 'member', joinedAt: Date.now() },\n    { memberId: 'member3', userId: 'user3', bubbleId: 'bubble1', name: 'Dad', status: 'Safe', role: 'member', joinedAt: Date.now() }\n  ],\n  referrals: []\n};\n\nexport const API = {\n  // Create a new bubble (only when first user signs up)\n  createBubble: async (userId, firstName, lastName, bubbleName, userPhoto, relationshipRole) => {\n    const bubbleId = `bubble${Date.now()}`;\n    const memberId = `member${Date.now()}`;\n    const fullName = `${firstName} ${lastName}`;\n    \n    mockDB.bubbles.push({\n      bubbleId,\n      name: bubbleName || `${fullName}'s Bubble`,\n      createdBy: userId,\n      createdAt: Date.now()\n    });\n\n    mockDB.members.push({\n      memberId,\n      userId,\n      bubbleId,\n      name: fullName,\n      firstName,\n      lastName,\n      userPhoto,\n      relationshipRole,\n      status: 'Safe',\n      role: 'owner',\n      joinedAt: Date.now()\n    });\n\n    return { bubbleId, memberId };\n  },\n\n  // Generate referral for the BUBBLE (not for individual user)\n  generateReferral: async (bubbleId) => {\n    const token = `BUB${Math.random().toString(36).substr(2, 9).toUpperCase()}`;\n    mockDB.referrals.push({ \n      token, \n      bubbleId, \n      used: false,\n      createdAt: Date.now()\n    });\n    return { token };\n  },\n\n  // Join existing bubble = you see the SAME bubble as everyone else\n  joinBubble: async (token, userId, userName) => {\n    const ref = mockDB.referrals.find(r => r.token === token && !r.used);\n    if (!ref) throw new Error('Invalid invite code');\n    \n    const memberId = `member${Date.now()}`;\n    mockDB.members.push({\n      memberId,\n      userId,\n      bubbleId: ref.bubbleId,\n      name: userName,\n      status: 'Offline',\n      role: 'member',\n      joinedAt: Date.now()\n    });\n\n    ref.used = true;\n    return { bubbleId: ref.bubbleId, memberId };\n  },\n\n  // Get the ONE bubble this user belongs to\n  getUserBubble: async (userId) => {\n    const member = mockDB.members.find(m => m.userId === userId);\n    if (!member) return null;\n\n    const bubble = mockDB.bubbles.find(b => b.bubbleId === member.bubbleId);\n    const allMembers = mockDB.members.filter(m => m.bubbleId === member.bubbleId);\n    \n    return {\n      bubble,\n      currentMember: member,\n      allMembers: allMembers.map(m => ({\n        ...m,\n        isMe: m.userId === userId\n      }))\n    };\n  },\n\n  // Update status in the shared bubble\n  updateStatus: async (memberId, status) => {\n    const member = mockDB.members.find(m => m.memberId === memberId);\n    if (member) {\n      member.status = status;\n      member.lastUpdated = Date.now();\n    }\n    return { success: true };\n  },\n\n  // Everyone in the bubble can invite (optional: restrict to owner only)\n  canInvite: async (memberId) => {\n    const member = mockDB.members.find(m => m.memberId === memberId);\n    // Philosophy: Anyone in the bubble can grow it\n    return member ? true : false;\n  },\n\n  // Leave bubble\n  leaveBubble: async (memberId) => {\n    const index = mockDB.members.findIndex(m => m.memberId === memberId);\n    if (index > -1) {\n      mockDB.members.splice(index, 1);\n    }\n    return { success: true };\n  }\n};"],"mappings":"AAAA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAG;EACXC,KAAK,EAAE,CACL;IAAEC,EAAE,EAAE,OAAO;IAAEC,KAAK,EAAE,mBAAmB;IAAEC,IAAI,EAAE;EAAQ,CAAC,EAC1D;IAAEF,EAAE,EAAE,OAAO;IAAEC,KAAK,EAAE,0BAA0B;IAAEC,IAAI,EAAE;EAAc,CAAC,EACvE;IAAEF,EAAE,EAAE,OAAO;IAAEC,KAAK,EAAE,0BAA0B;IAAEC,IAAI,EAAE;EAAc,CAAC,CACxE;EACD;EACAC,OAAO,EAAE,CACP;IACEC,QAAQ,EAAE,SAAS;IACnBC,IAAI,EAAE,sBAAsB;IAC5BC,SAAS,EAAE,OAAO;IAClBC,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;EACtB,CAAC,CACF;EACD;EACAC,OAAO,EAAE,CACP;IAAEC,QAAQ,EAAE,SAAS;IAAEC,MAAM,EAAE,OAAO;IAAER,QAAQ,EAAE,SAAS;IAAEC,IAAI,EAAE,OAAO;IAAEQ,MAAM,EAAE,MAAM;IAAEC,IAAI,EAAE,OAAO;IAAEC,QAAQ,EAAEP,IAAI,CAACC,GAAG,CAAC;EAAE,CAAC,EACjI;IAAEE,QAAQ,EAAE,SAAS;IAAEC,MAAM,EAAE,OAAO;IAAER,QAAQ,EAAE,SAAS;IAAEC,IAAI,EAAE,KAAK;IAAEQ,MAAM,EAAE,MAAM;IAAEC,IAAI,EAAE,QAAQ;IAAEC,QAAQ,EAAEP,IAAI,CAACC,GAAG,CAAC;EAAE,CAAC,EAChI;IAAEE,QAAQ,EAAE,SAAS;IAAEC,MAAM,EAAE,OAAO;IAAER,QAAQ,EAAE,SAAS;IAAEC,IAAI,EAAE,KAAK;IAAEQ,MAAM,EAAE,MAAM;IAAEC,IAAI,EAAE,QAAQ;IAAEC,QAAQ,EAAEP,IAAI,CAACC,GAAG,CAAC;EAAE,CAAC,CACjI;EACDO,SAAS,EAAE;AACb,CAAC;AAED,OAAO,MAAMC,GAAG,GAAG;EACjB;EACAC,YAAY,EAAE,MAAAA,CAAON,MAAM,EAAEO,SAAS,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,SAAS,EAAEC,gBAAgB,KAAK;IAC5F,MAAMnB,QAAQ,GAAG,SAASI,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACtC,MAAME,QAAQ,GAAG,SAASH,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACtC,MAAMe,QAAQ,GAAG,GAAGL,SAAS,IAAIC,QAAQ,EAAE;IAE3CtB,MAAM,CAACK,OAAO,CAACsB,IAAI,CAAC;MAClBrB,QAAQ;MACRC,IAAI,EAAEgB,UAAU,IAAI,GAAGG,QAAQ,WAAW;MAC1ClB,SAAS,EAAEM,MAAM;MACjBL,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;IACtB,CAAC,CAAC;IAEFX,MAAM,CAACY,OAAO,CAACe,IAAI,CAAC;MAClBd,QAAQ;MACRC,MAAM;MACNR,QAAQ;MACRC,IAAI,EAAEmB,QAAQ;MACdL,SAAS;MACTC,QAAQ;MACRE,SAAS;MACTC,gBAAgB;MAChBV,MAAM,EAAE,MAAM;MACdC,IAAI,EAAE,OAAO;MACbC,QAAQ,EAAEP,IAAI,CAACC,GAAG,CAAC;IACrB,CAAC,CAAC;IAEF,OAAO;MAAEL,QAAQ;MAAEO;IAAS,CAAC;EAC/B,CAAC;EAED;EACAe,gBAAgB,EAAE,MAAOtB,QAAQ,IAAK;IACpC,MAAMuB,KAAK,GAAG,MAAMC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EAAE;IAC3ElC,MAAM,CAACkB,SAAS,CAACS,IAAI,CAAC;MACpBE,KAAK;MACLvB,QAAQ;MACR6B,IAAI,EAAE,KAAK;MACX1B,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;IACtB,CAAC,CAAC;IACF,OAAO;MAAEkB;IAAM,CAAC;EAClB,CAAC;EAED;EACAO,UAAU,EAAE,MAAAA,CAAOP,KAAK,EAAEf,MAAM,EAAEuB,QAAQ,KAAK;IAC7C,MAAMC,GAAG,GAAGtC,MAAM,CAACkB,SAAS,CAACqB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACX,KAAK,KAAKA,KAAK,IAAI,CAACW,CAAC,CAACL,IAAI,CAAC;IACpE,IAAI,CAACG,GAAG,EAAE,MAAM,IAAIG,KAAK,CAAC,qBAAqB,CAAC;IAEhD,MAAM5B,QAAQ,GAAG,SAASH,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;IACtCX,MAAM,CAACY,OAAO,CAACe,IAAI,CAAC;MAClBd,QAAQ;MACRC,MAAM;MACNR,QAAQ,EAAEgC,GAAG,CAAChC,QAAQ;MACtBC,IAAI,EAAE8B,QAAQ;MACdtB,MAAM,EAAE,SAAS;MACjBC,IAAI,EAAE,QAAQ;MACdC,QAAQ,EAAEP,IAAI,CAACC,GAAG,CAAC;IACrB,CAAC,CAAC;IAEF2B,GAAG,CAACH,IAAI,GAAG,IAAI;IACf,OAAO;MAAE7B,QAAQ,EAAEgC,GAAG,CAAChC,QAAQ;MAAEO;IAAS,CAAC;EAC7C,CAAC;EAED;EACA6B,aAAa,EAAE,MAAO5B,MAAM,IAAK;IAC/B,MAAM6B,MAAM,GAAG3C,MAAM,CAACY,OAAO,CAAC2B,IAAI,CAACK,CAAC,IAAIA,CAAC,CAAC9B,MAAM,KAAKA,MAAM,CAAC;IAC5D,IAAI,CAAC6B,MAAM,EAAE,OAAO,IAAI;IAExB,MAAME,MAAM,GAAG7C,MAAM,CAACK,OAAO,CAACkC,IAAI,CAACO,CAAC,IAAIA,CAAC,CAACxC,QAAQ,KAAKqC,MAAM,CAACrC,QAAQ,CAAC;IACvE,MAAMyC,UAAU,GAAG/C,MAAM,CAACY,OAAO,CAACoC,MAAM,CAACJ,CAAC,IAAIA,CAAC,CAACtC,QAAQ,KAAKqC,MAAM,CAACrC,QAAQ,CAAC;IAE7E,OAAO;MACLuC,MAAM;MACNI,aAAa,EAAEN,MAAM;MACrBI,UAAU,EAAEA,UAAU,CAACG,GAAG,CAACN,CAAC,KAAK;QAC/B,GAAGA,CAAC;QACJO,IAAI,EAAEP,CAAC,CAAC9B,MAAM,KAAKA;MACrB,CAAC,CAAC;IACJ,CAAC;EACH,CAAC;EAED;EACAsC,YAAY,EAAE,MAAAA,CAAOvC,QAAQ,EAAEE,MAAM,KAAK;IACxC,MAAM4B,MAAM,GAAG3C,MAAM,CAACY,OAAO,CAAC2B,IAAI,CAACK,CAAC,IAAIA,CAAC,CAAC/B,QAAQ,KAAKA,QAAQ,CAAC;IAChE,IAAI8B,MAAM,EAAE;MACVA,MAAM,CAAC5B,MAAM,GAAGA,MAAM;MACtB4B,MAAM,CAACU,WAAW,GAAG3C,IAAI,CAACC,GAAG,CAAC,CAAC;IACjC;IACA,OAAO;MAAE2C,OAAO,EAAE;IAAK,CAAC;EAC1B,CAAC;EAED;EACAC,SAAS,EAAE,MAAO1C,QAAQ,IAAK;IAC7B,MAAM8B,MAAM,GAAG3C,MAAM,CAACY,OAAO,CAAC2B,IAAI,CAACK,CAAC,IAAIA,CAAC,CAAC/B,QAAQ,KAAKA,QAAQ,CAAC;IAChE;IACA,OAAO8B,MAAM,GAAG,IAAI,GAAG,KAAK;EAC9B,CAAC;EAED;EACAa,WAAW,EAAE,MAAO3C,QAAQ,IAAK;IAC/B,MAAM4C,KAAK,GAAGzD,MAAM,CAACY,OAAO,CAAC8C,SAAS,CAACd,CAAC,IAAIA,CAAC,CAAC/B,QAAQ,KAAKA,QAAQ,CAAC;IACpE,IAAI4C,KAAK,GAAG,CAAC,CAAC,EAAE;MACdzD,MAAM,CAACY,OAAO,CAAC+C,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;IACjC;IACA,OAAO;MAAEH,OAAO,EAAE;IAAK,CAAC;EAC1B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}